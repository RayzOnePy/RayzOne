import telebot
import config
import logging

logger = telebot.logger
telebot.logger.setLevel(logging.DEBUG)

from telebot import types

bot = telebot.TeleBot(config.key)

@bot.message_handler(commands=['start'])
def welcome(message):
    sti = open('static/AnimatedSticker.tgs', 'rb')
    bot.send_sticker(message.chat.id, sti)

    markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
    item1 = types.KeyboardButton("Команды")

    markup.add(item1)

    bot.send_message(message.chat.id, "Добро пожаловать, {0.first_name}!\nЯ - <b>{1.first_name}</b>, бот созданный чтобы быть подопытным кроликом.".format(message.from_user, bot.get_me()), parse_mode="html", reply_markup=markup)

@bot.message_handler(content_types=['text'])
def cosd(message):
    if message.text == "Команды":
            
        markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
        item1 = types.KeyboardButton("Комментарии")
        item2 = types.KeyboardButton("Числа")
        item3 = types.KeyboardButton("Строки")
        item4 = types.KeyboardButton("Кавычки")
        item5 = types.KeyboardButton("Отступы")
        item6 = types.KeyboardButton("Оператор присваивания")
        item7 = types.KeyboardButton("Основные операторы")
        item8 = types.KeyboardButton("Основные типы данных")
        item9 = types.KeyboardButton("Список")
        item10 = types.KeyboardButton("Генераторы")
        item11 = types.KeyboardButton("Библиотека Math")
        item12 = types.KeyboardButton("Генерация случайных чисел")
        item13 = types.KeyboardButton("Преобразование типов данных")
        item14 = types.KeyboardButton("Встроенные функции")
        item15 = types.KeyboardButton("Чтение и запись данных в файл")
        item16 = types.KeyboardButton("Циклы")
        item17 = types.KeyboardButton("Условные операторы")
        item18 = types.KeyboardButton("Функции")
        item19 = types.KeyboardButton("Словарь")
        item20 = types.KeyboardButton("Исключения")
        item21 = types.KeyboardButton("Множества")
        item22 = types.KeyboardButton("Введение в ООП")
        item23 = types.KeyboardButton("Что такое точка?")
        item24 = types.KeyboardButton("Создание класса")
        item25 = types.KeyboardButton("Атрибуты и методы класса")
        item26 = types.KeyboardButton("Создание экземпляра")    
        markup.add(item1, item2, item3, item4, item5, item6, item7, item8, item9, item10, item11, item12, item13, item14, item15, item16, item17, item18, item19, item20, item21, item22, item23, item24, item25, item26)
        bot.send_message(message.chat.id, "Что бы вы хотели узнать?", reply_markup=markup)

    if message.text == "Комментарии":
        bot.send_message(message.chat.id, "Комментарии в Python начинаются со знака  #  и могут появляться в любом месте программы.\nКомментарий может занимать всю строчку:\n#print это функция   <- это комментарий\nprint('Hello, World!')\nили может находиться на строчке после какого-нибудь кода:\nprint('Hello, World!')   # print это функция\nВнимание:  любую строку можно превратить в комментарий, достаточно в начале строки  набрать комбинацию клавиш  Ctrl+/")
    elif message.text == "Числа":
        bot.send_message(message.chat.id, "Числа в Python бывают двух типов:\nцелые, например,  4\nвещественные, например,  5.02")
    elif message.text == "Строки":
        bot.send_message(message.chat.id, "Строка – это последовательность символов. Чаще всего строки – это просто некоторые наборы слов. Слова могут быть как на английском языке, так и  почти на любом языке мира.\nОперации со строками:\nstring[i] извлекает символ в позиции i\nstring[-1] извлекает последний символ\nstring[i:j] извлекает символы в диапазоне от i до j\nМетоды работы со строками:\nstring.upper() преобразует строку в верхний регистр\nString.lower() преобразует в строку в нижний регистр\nstring.count(x) подсчитывает, сколько раз появляется x\nstring.find(x) позиция первой строки вхождения x\nstring.replace(x, y) заменяет x на y\nstring.strip(x) удаляет как начальные, так и конечные символы x\nstring.join (List) объединяет список строк\nstring.format(x) возвращает строку, которая включает отформатированное представление x")
    elif message.text == "Кавычки":
        bot.send_message(message.chat.id, "Одинарные кавычки\nСтроку можно указать, используя одинарные кавычки, как например, 'Это строка'.  Любой одиночный символ в кавычках, например,  'ю'  — это строка. Пустая строка '' — это тоже строка. То есть строкой мы считаем всё, что находится внутри кавычек.\n\nДвойные кавычки\nЗапись строки в одинарных кавычках  это не единственный способ. Можно использовать и двойные кавычки, как например, ''Это строка''.  Для интерпретатора разницы между записями строки в одинарных и двойных кавычках нет.  \n\nВнимание:\nЕсли  строка началась с двойной кавычки — значит и закончиться должна на двойной кавычке. \nЕсли внутри строки мы хотим использовать двойные кавычки, то саму строку надо делать в одинарных кавычках. \n\nТеатр ''Современник''\nprint('Театр ''Современник''')\n\n\nТройные кавычки\nСтрока, занимающая несколько строк,  должна быть обрамлена тройными кавычками ('' '' ''  или ''').  Например:\n\n'''В Python можно использовать одинарные, двойные и тройные кавычки, чтобы обозначить строку'''")
    elif message.text == "Отступы":
        bot.send_message(message.chat.id, "Сдвиг строки с помощью пробелов называется отступами.\n\nДля выделения блоков программного кода используются отступы.\nВ одном и том же блоке кода должно быть одинаковое количество пробелов. \nКоличество пробелов в отступах произвольно.  Общепринято использовать четыре пробела. ")
    elif message.text == "Оператор присваивания":
        bot.send_message(message.chat.id, "Переменная – это именованная область памяти, в которой хранятся данные. Данные помещаются в эту область памяти, как в ящик, с помощью оператора присваивания. Общая форма  записи операции присваивания:\n\nимя = значение\nЗнакомый нам знак  равно (=) в программирование это знак операции присваивания. Различие между  знаками равно и присваивания в следующем.\nНапример:\n\nb = 4\nb = b + 2 # переменная  будет иметь значение 6\n\nВ обычной математической записи  выражение  b (рано) = b + 2 является не верным. Однако запись оператора присваивания b (присвоить) = b + 2 правильная и означает следующее: к текущему значению переменной b, например, оно было равно 4, прибавляется число 2 , и после  выполнения данного оператора, значение переменной будет равно 6.")
    elif message.text == "Основные операторы":
        bot.send_message(message.chat.id, "Оператор\n\nКраткое описание:\n\n+   Сложение (сумма x и y)\n\n-   Вычитание (разность x и y)\n\n*   Умножение (произведение x и y)\n\n/   Деление\n\nВнимание! Если x и y целые, то результат всегда будет целым числом! Для получения вещественного результата хотя бы одно из чисел должно быть вещественным. Пример: 40/5 → 8, а вот 40/5.0 → 8.0\n\n=   Присвоение\n\n+=  y+=x; эквивалентно y = y + x;\n\n-=  y-=x; эквивалентно y = y - x;\n\n*=  y*=x; эквивалентно y = y * x;\n\n/=  y/=x; эквивалентно y = y / x;\n\n%=  y%=x; эквивалентно y = y % x;\n\n==  Равно\n\n!=  не равно\n\n>   Больше\n\n<   Меньше\n\n>=  больше или равно\n\n<=  меньше или равно\n\n\n%   Деление по модулю - деление, в котором возвращается остаток.\n\n4 % 2 в результате будет 0\n5 % 2 в результате будет 1\n\n//  Целочисленное деление - деление, в котором возвращается целая часть результата. Часть после запятой отбрасывается\n\n4 // 3 в результате будет 1\n25 // 6 в результате будет 4\n\n**  Возведение в степень\n\n5 ** 2 в результате будет 25\n\nand логическое И\n\nor  логическое ИЛИ\n\nnot логическое отрицание НЕ")
    elif message.text == "Основные типы данных":
        bot.send_message(message.chat.id, '''Имя      Тип     Описание\n\nЦелые числа     int     1, 2, 3\n\nВеществекнные числа     float       1.1,  2.1,  5.03\n\nСтроки      str     Последовательность символов: "abc", "pyhton", "123"\n\nСписки      list        Последовательность объектов: [1, 2.0, "Привет!"]\n\nСловари     dist        Список пар «ключ – значение» {"пять":5 }\n\nКортежи     tuple       Последовательность неизменных объектов:(20,25 )\n\nМножества       set     Последовательность уникальных объектов:{4,5,6,}\n\nБулевы значения     bool        Логические значения: True или False''')
    elif message.text == "Список":
        bot.send_message(message.chat.id, "Список\nСписок (list) представляет тип данных, который хранит набор или последовательность элементов.\nДля создания списка в квадратных скобках [ ] через запятую перечисляются все его элементы.\n\nСоздание пустого списка\n\nnumbers = [] \nСоздание списка чисел:\n\nnumbers = [1, 2, 3, 4, 5] # имя списка numbers, он содержит 5 элементов\nСоздание списка слов:\n\nwords = ['C', 'C++', 'Java', 'Python'] # имя списка words, он  содержит 4 элемента\n\nСоздание списка из элементов разного типа\n\nlistNum = [1,2,3,4, 'один', 'два', 'три', 'четыре'] # имя списка listNum,    список     содержит целые числа и строки\n\nДля управления элементами списки имеют целый ряд методов. Некоторые из них:\n\nappend(item): добавляет элемент item в конец списка\ninsert(index, item): добавляет элемент item в список по индексу index\nremove(item): удаляет элемент item. Удаляется только первое вхождение элемента. Если элемент не найден, генерирует исключение ValueError\nclear(): удаление всех элементов из списка\nindex(item): возвращает индекс элемента item. Если элемент не найден, генерирует исключение ValueError\npop([index]): удаляет и возвращает элемент по индексу index. Если индекс не передан, то просто удаляет последний элемент.\ncount(item): возвращает количество вхождений элемента item в список\nsort([key]): сортирует элементы. По умолчанию сортирует по возрастанию. Но с помощью параметра key мы можем передать функцию сортировки.\nreverse(): расставляет все элементы в списке в обратном порядке\nКроме того, Python предоставляет ряд встроенных функций для работы со списками:\n\nlen(list): возвращает длину списка\nsorted(list, [key]): возвращает отсортированный список\nmin(list): возвращает наименьший элемент списка\nmax(list): возвращает наибольший элемент списка]")
    elif message.text == "Генераторы":
        bot.send_message(message.chat.id, "Генераторы\nДля создания списков, заполненных по более сложным формулам можно использовать генераторы: выражения, позволяющие заполнить список значениями, вычисленными по некоторым формулам. \n\nОбщий вид генератора следующий:\n[выражение for переменная in последовательность]\nПример. Создать список чисел от 0 до 10\n\nЗаписываем генератор\n\n             [i for i in range(0, 10)]\nВся конструкция заключается в квадратные скобки, потому что будет создан список. Внутри квадратных скобок можно выделить три части:\n\n1) что делаем с элементом i:   просто   добавляем значение i в список\n2) что берем: берем i\n3) откуда берем:  из объекта range.\nЧасти отделены друг от друга ключевыми словамиfor и in.\n\nlist_of_numbers = []             #создаем пустой список\nlist_of_numbers = [i for i in range(0, 10)]\nprint(list_of_numbers)Результат работы программы\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nПример. Создать список заглавных букв английского алфавита.Код символа 'A' – 65, код символа 'Z' – 91. Поскольку символы идут подряд, то возможно использовать генератор.\n\nчто делаем: к значению элемента i применяем функцию chr(i).\n\nВнимание.Функция  chr(i) – по числовому коду символа возвращает сам символ.  Пример. chr(65)  даст символ 'A'.\n\nlist_of_char = []                   #создаем пустой список\nlist_of_char = [chr(i) for i in range(65, 91)]\nprint(list_of_char)Результат работы программы\n['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']\nПример.  Создать список строчный букв английского алфавита.Код символа 'a' – 97, код символа 'z' – 123. Поскольку символы идут подряд, то возможно использовать генератор.\n\nlist_of_char = []                    #создаем пустой список    \nlist_of_char = [chr(i) for i in range(97, 123)]\nprint(list_of_char)Результат работы программы\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']")
    elif message.text == "Библиотека Math":
        bot.send_message(message.chat.id, "Библиотека math\nДля проведения вычислений с действительными числами язык Python содержит много дополнительных функций, собранных в библиотеку, которая называется math. Для использования этих функций в начале программы необходимо подключить библиотеку, что делается командой\n\n\nimport math           # подключение модуля библиотеки\n\nПосле подключения программа получает доступ ко всем функциям, методам и классам, содержащимся в нём. После подключения можно вызвать любую функцию из подключенной библиотеки по следующему правилу: указывается имя модуля и через точку имя функции\n\nимя_модуля.имя_функции\n\nНапример, пусть мы хотим вызвать функцию вычисления Синус угла, задаваемого в радианах\nimport math\ny = sin(5)         # ошибка не подключен модуль math\nx = math.sin(5)    # записываем имя модуля и через точку имя функции\n\n\nМожно подключать не весь модуль, а какую-то его часть. Например, программист хочет использовать только одну функцию из математической библиотеки math. Если он подключит всю библиотеку, то будет добавлено более 40 функций, которые будут занимать место. Чтобы добавить в проект какую-то часть, используют ключевое слово from:\n\n\nfrom <имя подключаемого модуля> import <название функции>\n\nНапример.\n\nfrom math import sin       # подключена только одна функция sin\ny = sin(5)                 # операция выполнена\nx = cos(5)               # ошибка функция cos не подключена\n\n\nНиже приведен список основных функций модуля math. Некоторые из перечисленных функций (int, round, abs) являются стандартными и не требуют подключения модуля math для использования.\n\nФункция\n\nОписание\n\nОкругление\n\nint(x)\n\nОкругляет число в сторону нуля. Это стандартная функция, для ее использования не нужно подключать модуль math.\n\nround(x)\n\nОкругляет число до ближайшего целого. Если дробная часть числа равна 0.5, то число округляется до ближайшего четного числа.\n\nround(x, n)\n\nОкругляет число x до n знаков после точки. Это стандартная функция, для ее использования не нужно подключать модуль math.\n\nfloor(x)\n\nОкругляет число вниз («пол»), при этом floor(1.5) == 1, floor(-1.5) == -2\n\nceil(x)\n\nОкругляет число вверх («потолок»), при этом ceil(1.5) == 2, ceil(-1.5) == -1\n\nabs(x)\n\nМодуль (абсолютная величина). Это — стандартная функция.\n\nКорни, логарифмы\n\nsqrt(x)\n\nКвадратный корень. Использование: sqrt(x)\n\nlog(x)\n\nНатуральный логарифм. При вызове в виде log(x, b) возвращает логарифм по основанию b.\n\ne\n\nОснование натуральных логарифмов e = 2,71828...\n\nТригонометрия\n\nsin(x)\n\nСинус угла, задаваемого в радианах\n\ncos(x)\n\nКосинус угла, задаваемого в радианах\n\ntan(x)\n\nТангенс угла, задаваемого в радианах\n\nasin(x)\n\nАрксинус, возвращает значение в радианах\n\nacos(x)\n\nАрккосинус, возвращает значение в радианах\n\natan(x)\n\nАрктангенс, возвращает значение в радианах\n\natan2(y, x)\n\nПолярный угол (в радианах) точки с координатами (x, y).\n\ndegrees(x)\n\nПреобразует угол, заданный в радианах, в градусы.\n\nradians(x)\n\nПреобразует угол, заданный в градусах, в радианы.\n\npi\n\nКонстанта π = 3.1415...")
    elif message.text == "Генерация случайных чисел":
        bot.send_message(message.chat.id, "Генерация случайных чисел (модуль random)\nPython порождает случайные числа на основе формулы, так что они на самом деле не случайные, а, как говорят, псевдослучайные.\n\nМодуль random позволяет генерировать случайные числа и  имеет большое множество важных для практики функций. Рассмотрим  основные функции:\n\nrandom.random() - случайное число от 0 до 1.\nrandom.randint(A, B) - случайное целое число N, A ≤ N ≤ B.\nrandom.shuffle(list) перемешивает список случайным образом\nrandom.choice(list) возвращает один случайный элемент из списка\nПримеры\nФункция  random.random()случайное число от 0 до 1.\n\nimport random\nnumber = random.random()  # значение от 0.0 до 1.0\nprint(number)\nnumber = random.random() * 100  # значение от 0.0 до 100.0\nprint(number)\nФункция    random.randint(A, B) - случайное целое число N, A ≤ N ≤ B\n\nimport random\nnumber = random.randint(20, 35)  # значение от 20 до 35\nprint(number)\nфункция random.shuffle(list) перемешивает список случайным образом\n\nimport random\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8]   # список\nrandom.shuffle(numbers)\nprint('numbers shuffle:',numbers)\nРезультат работы программы:\n\nnumbers shuffle: [6, 8, 1, 4, 7, 5, 2, 3]\n\nфункция  random.choice(list) возвращает один случайный элемент из списка\n\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8]\n random_number = random.choice(numbers)\n print('random_number:', random_number)\nrandom_number: 4")
    elif message.text == "Преобразование типов данных":
        bot.send_message(message.chat.id, "Преобразование типов данных\nФункция\n\nОписание\n\nint(x)\n\nПреобразовывает х в целое число.\nНапример, int(12.4) -> 12 или int('1') -> 1\n\nfloat(x)\n\nПреобразовывает х в число с плавающей точкой.\nНапример, float(10) -> 10.0\n\nstr(x)\n\nПреобразовывает х в строку.\nНапример, str(10) -> '10'")
    elif message.text == "Встроенные функции":
        bot.send_message(message.chat.id, "Встроенные функции\nprint (x, sep = 'y') печатает x объектов, разделенных y\nlen (x) возвращает длину x (s, L или D)\nmin (L ) возвращает минимальное значение в L\nmax (L) возвращает максимальное значение в L\nsum (L) возвращает сумму значений в диапазоне L\nrange(n1,n2,n) (n1, n2, n) возвращает последовательность чисел от n1 до n2 с шагом n\nabs (n) возвращает абсолютное значение n\nround (n1, n) возвращает число n1, округленное до n цифр\ntype (x) возвращает тип x (string, float, list, dict…)\nstr (x) преобразует x в string \nlist (x) преобразует x в список\nint (x) преобразует x в целое число\nfloat (x) преобразует x в число с плавающей запятой\nhelp (s) печатает справку о x\nmap (function, L) Применяет функцию к значениям в L\n \nПринятые обозначения: x, y обозначают любые значения данных, s - строку, n - число, L - список, где i, j - индексы списка, D - словарь, а k - ключ словаря")
    elif message.text == "Чтение и запись данных в файл":
        bot.send_message(message.chat.id, "Чтение и запись данных в файл\nf = open(<path>,‘r')\nf.read(<size>)\nf.readline(<size>)\nf.close()\n \n\nf = open(<path>,’r’)\nfor line in f:\n    <code>\nf.close()\n\nf = open(<path>,'w')\nf.write(<str>)\nf.close()")
    elif message.text == "Циклы":
        bot.send_message(message.chat.id, "Циклы\nwhile <condition>:\n      <code>\n  \n\n\nfor <variable> in <list>:\n    <code>\n   \n\n\nfor <variable> in range(start,stop,step):\n    <code>\n\n\nfor key, value in dict.items():\n    <code> \n\n \n\nОператоры управления циклом\n\nbreak завершает выполнение цикла\ncontinue переходит к следующей итерации \npass  ничего не делает")
    elif message.text == "Условные операторы":
        bot.send_message(message.chat.id, '''Условный оператор if\nОператор if позволяет изменить порядок выполнения операторов в зависимости от истинности или ложности некоторого условия. Формат оператора может быть записан в двух формах: полной и неполной форме.\n\nif  условие:\n    # блок if\n    <операторы>\nelse:\n    # блок else\n    <операторы>\n  \n\nБлок инструкций if будет выполнен, если условие истинно. Если условие ложно, будет выполнен блок инструкций else.\n\nВ условном операторе  может отсутствовать слово else и последующий блок. Такая инструкция называется неполным ветвлением.\n\n \n\nПример 5.  Записать следующее   выражение  на языке Python.\nЕсли a  >  0,  то  b  =  1,   иначе  a  =  0.  \n\n \n\nprint ("Введите значение a: ")\na = int(input())\nif a > 0:\n    b = 1      \nelse:\n    b = 0\nprint("b = ", b)\n\n \nУсловный оператор  elif\nif условие_1:\n   # блок if\n   <операторы>\nelif условие_2:\n   # первый блок elif\n   <операторы>\nelif условие_3:\n   <операторы>\n...\nelse\n   # блок else\n   <операторы>   \n \n\nКлючевое слово elif  расшифровывается, как else + if. Это конструкция позволяет  реализовать алгоритм  выбора   необходимого варианта из нескольких альтернативных вариантов.  Оператор elif позволяет упростить код. Сделать его легче читаемым и позволяет избежать написание несколько условий  if.\n\n\nКогда исполняется инструкция if-elif-else, в первую очередь  проверяется условие_1.  Если условие истинно, тогда исполняется блок инструкций if .  Следующие условия и операторы пропускаются, и управление переходит к оператору  за  условным оператором if-elif-else.\n\n\nЕсли условие_1 оказывается ложным, тогда управление переходит к следующему условию elif,  и проверяется условие_2.  Если оно истинно, тогда исполняются инструкции внутри первого блока elif. Последующие инструкции внутри этого блока пропускаются. Этот процесс повторяется, пока не находится условие elif, которое оказывается истинным. Если такого нет, тогда исполняется блок операторов else\n\n\n Пример.  \n\nx = int(input())\n\ny = int(input())\n\nif x > 0 and y > 0:\n\n    print("Первая четверть")\n\nelif x > 0 and y < 0:\n\n    print("Четвертая четверть")\n\nelif y > 0:\n\n    print("Вторая четверть")\n\nelse:\n   print("Третья четверть")''')
    elif message.text == "Функции":
        bot.send_message(message.chat.id, '''Функции\nОпределение функции начинается с выражения def, которое состоит из имени функции, набора скобок с параметрами и двоеточия. Параметры в скобках необязательны.\n\ndef function(<параметры>):\n     <code>\n    return <данные>\n \n\nПример.\n\ndef max(a, b):\n     if a > b:\n        return a\n     else:\n        return b\n  \nВыражение return прекращает выполнение функции и возвращает заданное  значение (называется возвращаемое значение). Ключевое слово не обязательно.\n\n \n\nАргументы - ключевые слова\n \n\nОсновные правила:\n\nКлючевые аргументы указываются перечислением ключ=значение\nПри вызове функции,  аргументы определяются  по имени.\nЭто позволяет пропускать аргументы или размещать их не по порядку, поскольку интерпретатор Python может использовать предоставленные ключевые слова (ключи) для сопоставления значений с параметрами.\nПример. Используем ключевые слова  name (имя), age (возраст) для функции person():\n\n# Определение функции\n\ndef person( name, age ):\n    print("Name: " + name + " age: " + str(age))\n \n\n\n# Вызов функции person\n\nperson( age = 24,   name = "Никита" )\nperson( name = "Мария",  age = 22 )\n\n \n\nРезультат:\n\nName: Никита age: 24\nName: Мария age: 22''')
    elif message.text == "Словарь":
        bot.send_message(message.chat.id, "Операции со словарем\ndict = {} определяет пустой словарь\n\ndict[k] = x сохраняет x, связанный с ключом k\n\ndict[k] извлекает элемент с ключом k\n\ndel dict[k] удаляет элемент с ключом k\n \n\nМетоды работы со словарем\n \n\ndict.keys() возвращает список ключей\n\ndict.values​​() возвращает список значений\n\ndict.items() возвращает список пар (ключ, значение)\n\ndict.get(k) возвращает значение, связанное с ключом k\n\ndict.pop() удаляет элемент, связанный с ключом, и возвращает его значение\n\ndict.update(D) добавляет значения ключей (D) в словарь\n\ndict.clear() удаляет все значения ключей из словаря\n\ndict.copy() возвращает копию словаря")
    elif message.text == "Исключения":
        bot.send_message(message.chat.id, " Исключения\n Исключения - это ошибки, которые приводят к сбою программ. Они часто происходят из-за плохого ввода или ошибок программирования. Наша задача-предвидеть и обрабатывать эти исключения, чтобы предотвратить сбои в наших программах.\n\n \n\ntry:\n\n    <code>\n\nexcept <error>:\n\n    <code>\n\nelse:\n\n    <code>")
    elif message.text == "Множества":
        bot.send_message(message.chat.id, ''' Множества\n Множество — это совокупность неповторяющихся элементов, расположенных в случайном порядке. При этом они могут быть как числовыми, так и символьными.\n\n \n\nitems = set()\n\nitems.add("Яблоко")\n\nitems.add("Апельсин")\n\nitems.add(1)\n\nitems.add("Машина")\n\nitems.remove("Машина")''')
    elif message.text == "Введение в ООП":
        bot.send_message(message.chat.id, "Краткое введение в ООП\nОбъектно-ориентированное программирование (ООП) – технология разработки сложного программного обеспечения, в которой программа строится в виде совокупности объектов и их взаимосвязей.\n\nОбъединение данных и действий, производимых над этими данными, в единое целое, которое называется объектом – является одним из основных принципов ООП.\n\nОсновными понятиями являются понятие класса и объекта.\n\nКласс является типом данных, определяемым пользователем и представляет собой структуру в виде данных и методов для работы с данными.\nФормально Класс — это шаблон, по которому будет сделан объект.\n\nОбъект является экземпляром класса. Объект  и экземпляр - это одно и то же.\n\n\nВот пример. Форма для изготовления печенья – это класс, а само печенье это объект или экземпляр класса, т.е. это конкретное изделие. Печенье имеет размеры, цвет, состав – это атрибуты класса. Также в классе описываются методы, которые предназначены для чтения или изменения данных объекта.\n\nВ Python характеристики  объекта, называются атрибутами, а действия, которые мы можем проделывать с объектами, — методами. Методами в Python  называют функции, которые определяются внутри класса.\n\nОбъект = атрибуты + методы ")
    elif message.text == "Что такое точка?":
        bot.send_message(message.chat.id, "Что такое точка?\n В приведенных примерах между именем объекта и именем атрибута или метода стоит точка. Это обозначение, которое применяется, когда нужно обратиться к атрибутам или методами объекта      \n\nобъект.атрибут, например, так можно изменить цвет мяча  ball.color = «зеленый»\nобъект.метод()  например,  так можно переместить мяч      ball. Move( )")
    elif message.text == "Создание класса":
        bot.send_message(message.chat.id, " Создание класса в Python:\n Определение класса начинается с ключевого слова class, после него следует имя класса и двоеточие.\n\nclass имя_класса:\n           # тело класса \n          # объявление конструктора\n          # объявление атрибутов\n          # объявление методов \n\nОсновные определения \n\nМетод __init__  или Конструктор\n\n В процессе создания объекта  атрибутам класса необходимо задать начальные значения. Это действие  называется инициализацией.  Для этой цели используется   специальный метод __init__(), который  называется методом инициализации или  конструктором.    Метод __init__ запускается при создании экземпляра класса - один раз. Обратите внимание на двойные подчёркивания в начале и в конце имени.\nСинтаксис метода следующий:\n\ndef __init__(self, параметр1, параметр2):\n              self.атрибут1 = параметр1\n             self.атрибут2 = параметр2\nДва символа подчеркивания в начале  __init__ и  два символа подчеркивания в конце обязательны. Параметров у конструктора  параметр1, параметр2 может быть сколько угодно, но первым дожен быть параметр  self.")
    elif message.text == "Атрибуты и методы класса":
        bot.send_message(message.chat.id, ''' Атрибуты и методы класса\n Атрибуты класса\n\nХарактеристики  объекта, называются атрибутами и записываются в внутри конструктора с помощью переменной self.   Доступ к атрибутам осуществляется через переменную self.\n\nНапример, класс имеет атрибут  цвет – color, он должен быть записан как\n\n     self.color  \n \n\nМетоды  класса\n\nМетоды класса создаются посредством ключевого слова def , имени метода , слова self, которое всегда указывается как первый параметр метода\n\ndef имя метода(self, передаваемые параметры):\n       # тело метода\n \n\nПример. Создаем метод, который выводит на печать характеристики мяча\n\n def Show(self):\n       print("Мяч: ", self.color, self.size )\n \n\n Мы определили атрибуты класса и методы. Таким образом,  класс  для нашего мяча будет выглядеть так:\n\n \n\nclass Ball:\n    def __init__(self, color, size):\n         self.color =  color\n         self.size = size\n    def Show(self):\n       print("Мяч: ", self.color, self.size )''')
    elif message.text == "Создание экземпляра":
        bot.send_message(message.chat.id, '''Создание экземпляра\n Для создания объекта — экземпляра класса достаточно вызвать класс по имени и задать параметры конструктора. Пример. Предположим у нас есть конструктор\n\n              def __init__(self, color, size): \nПодставляем на место формальных параметров, которые указаны  в конструкторе\n\ndef __init__(self, color, size)  фактические, например,  для параметра color указываем "красный,",   а для  size задаем зачение "маленький".\n\nСоздание экземпларя будет выглядеть следующим образом.\n\nball = Ball("красный,","маленький")\n Переменная self автоматически примет значение ссылки при создании экземпляра класса.Обратиться к методу Show() можно так:\n\n ball.Show()\nБудет выведено:\n\nМяч:  красный, маленький''')    
bot.polling(none_stop=True)